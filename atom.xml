<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Chaoya Li</title>
    <link href="http://www.chaoya.info/atom.xml" rel="self" />
    <link href="http://www.chaoya.info" />
    <id>http://www.chaoya.info/atom.xml</id>
    <author>
        <name>Chaoya Li</name>
        <email>chaoya@chaoya.info</email>
    </author>
    <updated>2016-01-03T00:00:00Z</updated>
    <entry>
    <title>自动微分简介</title>
    <link href="http://www.chaoya.info/articles/2016-01-03-ad.html" />
    <id>http://www.chaoya.info/articles/2016-01-03-ad.html</id>
    <published>2016-01-03T00:00:00Z</published>
    <updated>2016-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
  <div class="date">2016-01-03</div>
</div>

<h2 id="什么是自动微分">什么是自动微分</h2>
<p>在数值优化算法中，经常需要用到函数的导数。为了计算出一个函数的导数，通常有两种方法：</p>
<ul>
<li>符号微分（<a href="https://en.wikipedia.org/wiki/Symbolic_computation">Symbolic Diferentiation</a>）</li>
<li>数值微分（<a href="https://en.wikipedia.org/wiki/Numerical_differentiation">Numerical Differentiation</a>）</li>
</ul>
<p>符号微分，简而言之就是让机器像人一样，根据一套有限的函数求导法则，对函数表达式进行变换，得出最终的表达式，从而计算出导数。常见的符号计算系统有 Mathematica；还有 <a href="http://www.sympy.org/en/index.html">SymPy</a> ，这是一个用于符号计算的 Python 的库。数值微分，则是根据函数的泰勒展开，使用有限差分法估得导数。</p>
<p>无论是符号微分还是数值微分，都有他们的缺陷。符号微分必须要显示地知道函数的表达式，而且当表达式过于复杂时，计算代价很高。而数值微分则受限于机器的浮点精度，会产生较大的误差。</p>
<p>自动微分是与符号微分、数值微分完全不同的求导方法，既不会产生很高的计算代价，也不会带来额外的误差。它的核心思想有两点：</p>
<ol style="list-style-type: decimal">
<li>所有函数都是简单函数的复合；</li>
<li>根据链式法则，对函数的求导可以被分解为对简单函数求导的复合。</li>
</ol>
<p>下面分别介绍自动微分对一元函数、多元函数与向量函数的求导过程。</p>
<h2 id="一元函数的微分">一元函数的微分</h2>
<p>给定可微函数 <span class="math inline">\(f(x):\mathbb{R}\rightarrow\mathbb{R}\)</span>，其微分 <span class="math inline">\(df(x)=f&#39;(x)\,dx\)</span>。其中 <span class="math inline">\(f&#39;(x)\)</span> 是 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\(x\)</span> 的导数。若 <span class="math inline">\(x\)</span> 是关于 <span class="math inline">\(t\)</span> 的可微函数 <span class="math inline">\(x(t):\mathbb{R}\rightarrow\mathbb{R}\)</span>，则根据链式法则有 <span class="math display">\[\frac{df(x)}{dt}=\frac{df(x)}{dx}\frac{dx(t)}{dt}=f&#39;(x)\,x&#39;(t)\]</span></p>
举个例子。有 <span class="math inline">\(f(x)=x^2\)</span>，<span class="math inline">\(x(t)=t+1\)</span>，要求 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=1\)</span> 处的导数。其各变量依赖关系如下
<div class="center">
<img src="/img/ad-sample1.png" alt="" />
</div>
<p>从左往右，我们分别得到 <span class="math inline">\(t=1\)</span>，<span class="math inline">\(x=t+1=2\)</span>，<span class="math inline">\(\frac{dx}{dt}=1\)</span>，<span class="math inline">\(f=x^2=4\)</span>，<span class="math inline">\(\frac{df}{dx}=2x=4\)</span>，因此 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=1\)</span> 处的导数为 <span class="math inline">\(\frac{df}{dt}=\frac{df}{dx}\frac{dx}{dt}=4\times 1=4\)</span>。</p>
<p>看上去很简单是不是。自动微分的关键，就在于首先把函数分解为几个简单函数的复合，在这里就是加法与平方两种运算；然后再为每种简单函数定义好了导数，比如说，<span class="math inline">\(t+1\)</span> 的导数就是 <span class="math inline">\(1\)</span>，而 <span class="math inline">\(x^2\)</span> 的导数就是 <span class="math inline">\(2x\)</span>；最后通过对导数的组合，得到最终要求的导数。</p>
<h2 id="多元函数的微分">多元函数的微分</h2>
<p>给定可微函数 <span class="math inline">\(f(\mathbf{x}):\mathbb{R}^n\rightarrow\mathbb{R}\)</span>，其微分 <span class="math inline">\(df(\mathbf{x})=\nabla f(\mathbf{x})^T\,d\mathbf{x}\)</span>。其中 <span class="math inline">\(\nabla f(\mathbf{x})\)</span> 是 <span class="math inline">\(f\)</span> 的梯度，可以看作是广义的导数 <span class="math display">\[\nabla f(\mathbf{x})=(\frac{\partial f}{\partial x_1},\ldots,\frac{\partial f}{\partial x_n})^T\]</span></p>
<p>把 <span class="math inline">\(f\)</span> 看作是两个函数的复合：<span class="math inline">\(f(\mathbf{t}):\mathbb{R}^m\rightarrow\mathbb{R}\)</span>，<span class="math inline">\(\mathbf{t}(\mathbf{x}):\mathbb{R}^n\rightarrow\mathbb{R}^m\)</span>，多元函数的链式法则是 <span class="math display">\[\nabla_{\mathbf{x}} f(\mathbf{t}(\mathbf{x}))=\sum_{i=1}^{m}\frac{\partial f}{\partial t_i}\nabla t_i(\mathbf{x})\]</span></p>
举个例子。有 <span class="math inline">\(f(x,y)=(x+5)\times(x+y)\)</span>，要求 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x=2\)</span>，<span class="math inline">\(y=3\)</span> 处的导数。其各变量依赖关系如下
<div class="center">
<img src="/img/ad-sample2.png" alt="" />
</div>
<p>跟之前的例子类似，从左往右，我们分别得到 <span class="math inline">\(t_1=x+5=7\)</span>，<span class="math inline">\(t_2=x+y=5\)</span> 与偏导数 <span class="math inline">\(\frac{\partial t_1}{\partial x}=1\)</span>，<span class="math inline">\(\frac{\partial t_1}{\partial y}=0\)</span>，<span class="math inline">\(\frac{\partial t_2}{\partial x}=1\)</span>，<span class="math inline">\(\frac{\partial t_2}{\partial y}=1\)</span>，最后有 <span class="math inline">\(f=t_1\times t_2=7\times 5=35\)</span> 与偏导数 <span class="math inline">\(\frac{\partial f}{\partial t_1}=t_2=5\)</span>，<span class="math inline">\(\frac{\partial f}{\partial t_2}=t_1=7\)</span>，根据 <span class="math display">\[\frac{\partial f}{\partial x}=\frac{\partial f}{\partial t_1}\frac{\partial t_1}{\partial x}+\frac{\partial f}{\partial t_2}\frac{\partial t_2}{\partial x}=5\times 1+7\times 1=12\]</span> <span class="math display">\[\frac{\partial f}{\partial y}=\frac{\partial f}{\partial t_1}\frac{\partial t_1}{\partial y}+\frac{\partial f}{\partial t_2}\frac{\partial t_2}{\partial y}=5\times 0+7\times 1=7\]</span> 我们有 <span class="math display">\[\nabla f(x,y)=(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y})=(12,7)\]</span></p>
<h2 id="向量函数的微分">向量函数的微分</h2>
<p>给定可微函数 <span class="math inline">\(\mathbf{f}(\mathbf{x}):\mathbb{R}^n\rightarrow\mathbb{R}^m\)</span>，其微分 <span class="math inline">\(d\mathbf{f}(\mathbf{x})=\nabla\mathbf{f}(\mathbf{x})^T\,d\mathbf{x}\)</span>。梯度 <span class="math inline">\(\nabla\mathbf{f}(\mathbf{x})\)</span> 为 <span class="math display">\[\nabla\mathbf{f}(\mathbf{x})=\begin{bmatrix}
 \frac{\partial f_1}{\partial x_1} &amp; \frac{\partial f_2}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_1} \\
 \frac{\partial f_1}{\partial x_2} &amp; \frac{\partial f_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_2} \\
 \vdots &amp; \vdots &amp; &amp; \vdots \\
 \frac{\partial f_1}{\partial x_n} &amp; \frac{\partial f_2}{\partial x_n} &amp; \cdots &amp; \frac{\partial f_m}{\partial x_n}
\end{bmatrix}\]</span></p>
<p>与多元函数的微分类似，只要求得每一个 <span class="math inline">\(\nabla f_i(\mathbf{x})\)</span> 即可。</p>
<h2 id="实现与应用">实现与应用</h2>
<p>最常见的自动微分的实现通常基于运算符重载。借助 Haskell 中的类型类（typeclass）可以很方便地实现自动微分，比如 Matt Keeter 在他的一篇<a href="http://www.mattkeeter.com/projects/constraints/" title="Constraint Solver">博文</a>中用 40 行左右的代码实现了自动微分，并用其解决约束求解问题。更著名的是 Edward Kmett 大神写的 <a href="http://hackage.haskell.org/package/ad">ad</a> 库，十分强大。自动微分的应用非常广泛，具体的可以参见参考资料。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>自动微分社区，<a href="http://www.autodiff.org/" class="uri">http://www.autodiff.org/</a></li>
<li>维基百科，<a href="https://en.wikipedia.org/wiki/Automatic_differentiation" class="uri">https://en.wikipedia.org/wiki/Automatic_differentiation</a></li>
<li><a href="http://book.douban.com/subject/2870337/"><em>Numerical Optimization</em></a>, Jorge Nocedal and Stephen Wright, Springer 2006.</li>
</ul>
]]></summary>
</entry>

</feed>
